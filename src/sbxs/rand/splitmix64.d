/**
 * The SplitMix64 pseudo random number generator.
 *
 * This isn't a bad generator at all, but Xoroshiro128+ wins in almost every
 * aspect. Use this one only if you really need a decent generator with a
 * really small (8 bytes) state.
 *
 * It may also be useful when you have a single 64-bit value and need
 * to use it to seed some RNG requiring multiple values: just seed an
 * `SplitMix64` with the value you have and use it to generate as many
 * seeds as you need.
 *
 * License: MIT License, see the `LICENSE` file.
 *
 * Authors: Leandro Motta Barros (actually, just a D translation of the
 *     $(LINK2 http://xoroshiro.di.unimi.it/splitmix64.c, public domain C code)
 *     by Sebastiano Vigna).
 */

module sbxs.rand.splitmix64;

import std.traits: isIntegral;
import sbxs.rand.rng;

version (unittest)
{
    import sbxs.util.test;
}


/// The SplitMix64 (pseudo) random number generator.
public struct SplitMix64
{
    /// Constructs the generator from a given seed.
    public this(ulong seed)
    {
        this.seed(seed);
    }

    /// The maximum value this RNG will ever return.
    public enum maxValue = ulong.max;

    /// Returns a (pseudo) random number between 0 and `maxValue`.
    public ulong draw() @nogc nothrow pure
    {
        ulong z = (_state += 0x9E3779B97F4A7C15UL);
        z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9UL;
        z = (z ^ (z >> 27)) * 0x94D049BB133111EBUL;
        return z ^ (z >> 31);
    }

    /// Seeds (initializes) this generator with a given `seed` value.
    public void seed(T)(T seed)
        if (isIntegral!T)
    {
        _state = cast(ulong)seed;
    }

    /// The RNG state.
    private ulong _state;
}



// -----------------------------------------------------------------------------
// Unit tests
// -----------------------------------------------------------------------------

// Make sure this is a random number generator, according to my own criteria
static assert(isRNG!SplitMix64);

// Test `draw()`.
unittest
{
    auto rng = SplitMix64(112233);

    // Call `draw()` 1000 times, checking if values are in range. Well,
    // considering it is an `ulong`, it cannot be out of range, but anyway
    foreach (i; 0..1000)
        rng.draw().assertBetween(0, rng.maxValue);

    // Check the next few values, comparing them those generated by the
    // reference C implementation
    assert(rng.draw() == 17521931875799178301UL);
    assert(rng.draw() == 14383456051838709316UL);
    assert(rng.draw() == 2828063782273925862UL);
    assert(rng.draw() == 11956729851173419597UL);
    assert(rng.draw() == 15283991741788426049UL);

    // Again, with a different seed
    rng.seed(97531);
    foreach (i; 0..1000)
        rng.draw().assertBetween(0, rng.maxValue);

    assert(rng.draw() == 14309215551682402496UL);
    assert(rng.draw() == 13331760577475424929UL);
    assert(rng.draw() == 6476874722340802351UL);
    assert(rng.draw() == 13089128203191675115UL);
    assert(rng.draw() == 7925169073796594034UL);
}

// Call the "base" RNG functions, just to be sure they compile.
unittest
{
    import std.datetime;

    auto rng = SplitMix64(1234);

    rng.uniform(0.0, 1.0).assertBetween(0.0, 1.0);
    rng.uniform(1, 6).assertBetween(1, 6);
    assert(rng.bernoulli(1.0));
    rng.exponential(1.2);
    rng.normal(0.0, 1.3);
    rng.drawFromEnum!DayOfWeek();
}
